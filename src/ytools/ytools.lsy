;-*- Mode: Common-lisp; Package: ytools; -*-
(in-package :ytools)

;;; Copyright (C) 1976-2003 
;;;     Drew McDermott and Yale University.  All rights reserved
;;; This software is released under the terms of the Modified BSD
;;; License.  See file COPYING for details.

(defparameter ytools-package* (find-package :ytools))
(defparameter lisp-package* (find-package :common-lisp))
(defparameter cl-user-package* (find-package :common-lisp-user))

(declaim (special lisp-object-extn* lisp-source-extn*))

(push ':newfangled *features*)

#-excl
(eval-when (:compile-toplevel :load-toplevel :execute)
   (defvar readtable-table*
           (list (list ':lisp lisp-readtable*)
		 (list ':ytools ytools-readtable*)))
   (defun named-readtable (name &optional errorp)
      (setq name (intern (symbol-name name) :keyword))
      (let ((e (assoc name readtable-table*)))
	 (cond (e (cadr e))
	       (errorp
		(error "There is no readtable named ~s" name))
	       (t nil))))
   (defun (setf named-readtable) (rt name &optional errorp)
      (declare (ignore errorp))
      (setq name (intern (symbol-name name) :keyword))
      (let ((e (assoc name readtable-table*)))
	 (cond ((not e)
		(setq e (list name nil))
		(setq readtable-table*
		      (cons e readtable-table*))))
	 (setf (cadr e) rt)
	 rt)))

#+excl
(eval-when (:compile-toplevel :load-toplevel :execute)
   (import 'excl:named-readtable))

(setf (named-readtable ':ytools) ytools-readtable*)

(defparameter ytools-core-files*
    '("base" "datafun" "pathname" "chunk" "slurp"
      "files" "fload" "depend" "module"))
;;; -- chunk & slurp can be loaded in either order; they're independent
;;; of each other.

(defparameter bin-idio-dir*
   (cond ((equal bin-idio* "")
	  '())
	 (t
	  (let ((pn (parse-namestring bin-idio*)))
	     (let ((dir (pathname-directory pn)))
		(cond ((and (consp dir)
			    (eq (car dir) ':relative))
		       (cdr dir))
		      (t
		       (cerror "I will assume there is no special bin subdirectory for this Lisp"
			       "Illegal as bin subdirectory: ~s"
			       bin-idio)
		       '())))))))

(defparameter ytools-bin-relative*
              (append (pathname-directory (parse-namestring ytools-bin-path*))
		      (cond ((string= bin-idio* "") '())
			    (t (cdr (pathname-directory (parse-namestring bin-idio*)))))
		      '("ytools")))

;;;;	     '(:relative :back "bin" "ytools")

(defparameter dir-delim*
     (cond ((= (length ytools::directory-delimiter*)
	       1)
	    (elt ytools::directory-delimiter* 0))
	   (t
	    (error "YTools requires directory-delimiter to be ~
                    exactly one character, not ~s"
		  ytools::directory-delimiter*))))


;;;;(defparameter ytools-home-dir* "~/CVSified/prog/ytools/")
;;;;(defparameter lisp-object-extn* "fasl")

(defparameter ytools-dir-pathname*
              (parse-namestring ytools-home-dir*))

(defparameter ytools-bin-dir-pathname*
   (let ((dir-list (pathname-directory (pathname ytools-bin-path*)))
	 (pn (pathname ytools-dir-pathname*)))
      ;; This mimic code in ytools/pathname.lisp --
      (cond ((not (listp dir-list))
	     (error "Unexpected non-list directory for ~s"
		    ytools-bin-path*)))
      (cond ((eq (car dir-list) ':relative)
	     (setq dir-list (cdr dir-list))))
      (let ((start (pathname-directory pn)))
	 (cond ((and (consp start) (eq (car start) ':absolute))
		(let ((above-dirs (reverse (cdr start)))
		      (below-dirs '())
		      (from-dir-list '()))
		   ;; We use 'dir-list' as a set of instructions for arriving
		   ;; at a relative directory.
		   ;; As we go, the three variables above represent the
		   ;; directories traversed so far, leaving us in the "current
		   ;; directory."
		   ;; 'above-dirs' is list (in ascending order) of directories
		   ;; above (and including) the current dir.
		   ;; 'below-dirs' is list (in descending order)
		   ;; of directories we passed on the way up to current dir.
		   ;; 'from-dir-list' is a list (in ascending order) of
		   ;; directories copied from 'dir-list'.
		   (dolist (d dir-list)
		      (cond ((or (member d '(:back :up)) (equal d ".."))
			     (cond ((null from-dir-list)
				    ;; Go up one layer, recording in
				    ;; 'below-dirs' the directory
				    ;; passed.--
				    (cond ((null above-dirs)
					   (error "Relative directory ~s undefined wrt ~s"
						  dir-list pn))
					  (t
					   (push (pop above-dirs) below-dirs))))
				 ;; But once we've started recording
				 ;; directories in 'from-dir-list', a
				 ;; ".." directory is a puzzle. --
				   ((null above-dirs)
				    ;; We either go up and leave
				    ;; 'from-dir-list' alone, or, if we
				    ;; can't go up, we interpret ".." as
				    ;; perversely instructing us to undo
				    ;; the last addition to
				    ;; 'from-dir-list' --
				    (pop from-dir-list))
				   (t
				    ;; This is the case where we can 
				    ;; go up (pop 'above-dirs') and leave
				    ;; 'from-dir-list' and 'below-dirs'
				    ;; alone --
				    (pop above-dirs))))
			    ((member d '(-- "--") :test #'equal)
			     ;; Special flag that means *don't* record in
			     ;; 'below-dirs' the last layer we passed.
			     ;; This makes sense only if this layer does
			     ;; not help discriminate subdirectories.
			     ;; Useful for purging "src" layers from "bin"
			     ;; directories (assuming *all* "bin"
			     ;; subdirectories come from "src"
			     ;; subdirectories).--
			     (pop below-dirs))
			    (t
			     ;; A normal directory gets copied to
			     ;; 'from-dir-list' --
			     (push d from-dir-list))))
		(format t "above-dirs = ~s~%from-dir-list = ~s~%below-dirs = ~s~%"
			above-dirs from-dir-list below-dirs)
		   (let ((res-pn
			     (make-pathname
				 :directory
				    `(:absolute ,@(reverse above-dirs)
						,@(reverse from-dir-list)
						,@below-dirs)
				 :type lisp-object-extn*)))
		      (ensure-directories-exist res-pn)
		      res-pn)))
	       (t
		(error "Can't take relative directory with respect to relative directory ~s"
		       pn))))))

(setq *features* (adjoin ':ytools *features*))

(cl:defun load-core ()
      (dolist (bf ytools-core-files*)
	 (load (merge-pathnames
		  (make-pathname :name bf :type lisp-object-extn*)
		  ytools-bin-dir-pathname*)))
;;;;      (format t "Before loading ytinit, config-directory* = ~s~%"
;;;;	      config-directory*)
)
     
(cl:defun compile-core ()
   (dolist (bf ytools-core-files*)
      (let ((lisp-file
	       (merge-pathnames
		  (make-pathname :name bf :type "lisp")
		  ytools-dir-pathname*))
	    (fasl-file
	       (ensure-directories-exist
		  (merge-pathnames
		     (make-pathname :name bf :type lisp-object-extn*)
		     ytools-bin-dir-pathname*))))
	 (compile-file lisp-file :output-file fasl-file)
	 (load fasl-file))))
     
(cl:defun use-ytools (&optional (pkg *package*))
   (shadowing-import '(ytools::defun ytools::defmacro ytools::eval-when)
		     pkg)
   (use-package :ytools pkg))

(eval-when (:load-toplevel :execute)
  (export '(use-ytools named-readtable in-ytools)))

(setq *features* (adjoin ':ytools *features*))

(shadowing-import 'ytools :cl-user)

(defun in-ytools ()
   (setq *readtable* ytools-readtable*)
   (in-package :ytools))

(defconstant +ytools-version+ "1.5.1")
